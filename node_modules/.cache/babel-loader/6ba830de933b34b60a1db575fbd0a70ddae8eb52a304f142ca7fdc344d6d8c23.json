{"ast":null,"code":"/**\n * Module dependencies\n */\n\nvar util = require('util');\n//var Writable  = require('stream').Writable;\n\n// This is a workaround to implement a _flush method for Writable (like for Transform) to emit the 'finish' event only after all data has been flushed to the underlying system (GridFS). See https://www.npmjs.com/package/flushwritable and https://github.com/joyent/node/issues/7348\nvar FlushWritable = require('flushwritable');\n\n/**\n * expose\n * @ignore\n */\n\nmodule.exports = exports = GridWriteStream;\n\n/**\n * GridWriteStream\n *\n * @param {Grid} grid\n * @param {Object} options (optional)\n */\n\nfunction GridWriteStream(grid, options) {\n  if (!(this instanceof GridWriteStream)) return new GridWriteStream(grid, options);\n  FlushWritable.call(this);\n  this._opened = false;\n  this._opening = false;\n  this._writable = true;\n  this._closing = false;\n  this._destroyed = false;\n  this._errorEmitted = false;\n  this._grid = grid;\n\n  // a bit backwards compatible\n  if (typeof options === 'string') {\n    options = {\n      filename: options\n    };\n  }\n  this.options = options || {};\n  if (this.options._id) {\n    this.id = grid.tryParseObjectId(this.options._id);\n    if (!this.id) {\n      this.id = this.options._id;\n    }\n  }\n  this.name = this.options.filename; // This may be undefined, that's okay\n\n  if (!this.id) {\n    //_id not passed or unparsable? This is a new file!\n    this.id = new grid.mongo.ObjectID();\n    this.name = this.name || ''; // A new file needs a name\n  }\n\n  this.mode = 'w'; //Mongodb v2 driver have disabled w+ because of possible data corruption. So only allow `w` for now.\n\n  // The value of this.name may be undefined. GridStore treats that as a missing param\n  // in the call signature, which is what we want.\n  this._store = new grid.mongo.GridStore(grid.db, this.id, this.name, this.mode, this.options);\n  this._delayedWrite = null;\n  this._delayedFlush = null;\n  this._delayedClose = null;\n  var self = this;\n  self._open();\n}\n\n/**\n * Inherit from stream.Writable (FlushWritable for workaround to defer finish until all data flushed)\n * @ignore\n */\n\nutil.inherits(GridWriteStream, FlushWritable);\n\n// private api\n\n/**\n * _open\n *\n * @api private\n */\n\nGridWriteStream.prototype._open = function () {\n  if (this._opened) return;\n  if (this._opening) return;\n  this._opening = true;\n  var self = this;\n  this._store.open(function (err, gs) {\n    self._opening = false;\n    if (err) return self._error(err);\n    self._opened = true;\n    self.emit('open');\n\n    // If _close was called during _store opening, then it was delayed until now, so do the close now\n    if (self._delayedClose) {\n      var closed = self._delayedClose.cb;\n      self._delayedClose = null;\n      return self._closeInternal(closed);\n    }\n\n    // If _flush was called during _store opening, then it was delayed until now, so do the flush now (it's necessarily an empty GridFS file, no _write could have been called and have finished)\n    if (self._delayedFlush) {\n      var flushed = self._delayedFlush;\n      self._delayedFlush = null;\n      return self._flushInternal(flushed);\n    }\n\n    // If _write was called during _store opening, then it was delayed until now, so do the write now (_flush could not have been called yet as _write has not finished yet)\n    if (self._delayedWrite) {\n      var delayedWrite = self._delayedWrite;\n      self._delayedWrite = null;\n      return self._writeInternal(delayedWrite.chunk, delayedWrite.encoding, delayedWrite.done);\n    }\n  });\n};\n\n/**\n * _writeInternal\n *\n * @api private\n */\n\nGridWriteStream.prototype._writeInternal = function (chunk, encoding, done) {\n  // If destroy or error no more data will be written.\n  if (!this._writable) return;\n  var self = this;\n  // Write the chunk to the GridStore. The write head automatically moves along with each write.\n  this._store.write(chunk, function (err, store) {\n    if (err) return self._error(err);\n\n    // Emit the write head position\n    self.emit('progress', store.position);\n\n    // We are ready to receive a new chunk from the writestream - call done().\n    done();\n  });\n};\n\n/**\n * _write\n *\n * @api private\n */\n\nGridWriteStream.prototype._write = function (chunk, encoding, done) {\n  if (this._opening) {\n    // if we are still opening the store, then delay the write until it is open.\n    this._delayedWrite = {\n      chunk: chunk,\n      encoding: encoding,\n      done: done\n    };\n    return;\n  }\n\n  // otherwise, do the write now\n  this._writeInternal(chunk, encoding, done);\n};\n\n/**\n * _flushInternal\n *\n * @api private\n */\n\nGridWriteStream.prototype._flushInternal = function (flushed) {\n  this._close(flushed);\n};\n\n/**\n * _flush\n *\n * @api private\n */\n\nGridWriteStream.prototype._flush = function (flushed) {\n  // _flush is called when all _write() have finished (even if no _write() was called (empty GridFS file))\n\n  if (this._opening) {\n    // if we are still opening the store, then delay the flush until it is open.\n    this._delayedFlush = flushed;\n    return;\n  }\n\n  // otherwise, do the flush now\n  this._flushInternal(flushed);\n};\n\n/**\n * _closeInternal\n *\n * @api private\n */\n\nGridWriteStream.prototype._closeInternal = function (cb) {\n  if (!this._opened) return;\n  if (this._closing) return;\n  this._closing = true;\n  var self = this;\n  this._store.close(function (err, file) {\n    self._closing = false;\n    self._opened = false;\n    if (err) return self._error(err);\n    self.emit('close', file);\n    if (cb) cb();\n  });\n};\n\n/**\n * _close\n *\n * @api private\n */\n\nGridWriteStream.prototype._close = function _close(cb) {\n  if (this._opening) {\n    // if we are still opening the store, then delay the close until it is open.\n    this._delayedClose = {\n      cb: cb\n    };\n    return;\n  }\n\n  // otherwise, do the close now\n  this._closeInternal(cb);\n};\n\n/**\n * _error\n *\n * @api private\n */\n\nGridWriteStream.prototype._error = function _error(err) {\n  // Stop receiving more data to write, emit `error` and close the store\n  if (this._errorEmitted) return;\n  this._errorEmitted = true;\n  this._writable = false;\n  this.emit('error', err);\n  this._close();\n};\n\n// public api\n\n/**\n * destroy\n *\n * @api public\n */\n\nGridWriteStream.prototype.destroy = function destroy(err) {\n  // Abort the write stream, even if write not completed\n  if (this._destroyed) return;\n  this._destroyed = true;\n  var self = this;\n  process.nextTick(function () {\n    self._error(err);\n  });\n};\n\n/**\n * destroySoon\n *\n * @api public\n * @deprecated just use destroy()\n */\n\nGridWriteStream.prototype.destroySoon = function destroySoon() {\n  return this.destroy();\n};","map":{"version":3,"names":["util","require","FlushWritable","module","exports","GridWriteStream","grid","options","call","_opened","_opening","_writable","_closing","_destroyed","_errorEmitted","_grid","filename","_id","id","tryParseObjectId","name","mongo","ObjectID","mode","_store","GridStore","db","_delayedWrite","_delayedFlush","_delayedClose","self","_open","inherits","prototype","open","err","gs","_error","emit","closed","cb","_closeInternal","flushed","_flushInternal","delayedWrite","_writeInternal","chunk","encoding","done","write","store","position","_write","_close","_flush","close","file","destroy","process","nextTick","destroySoon"],"sources":["D:/bot/Frontend/node_modules/gridfs-stream/lib/writestream.js"],"sourcesContent":["\n/**\n * Module dependencies\n */\n\nvar util = require('util');\n//var Writable  = require('stream').Writable;\n\n// This is a workaround to implement a _flush method for Writable (like for Transform) to emit the 'finish' event only after all data has been flushed to the underlying system (GridFS). See https://www.npmjs.com/package/flushwritable and https://github.com/joyent/node/issues/7348\nvar FlushWritable = require('flushwritable');\n\n/**\n * expose\n * @ignore\n */\n\nmodule.exports = exports = GridWriteStream;\n\n/**\n * GridWriteStream\n *\n * @param {Grid} grid\n * @param {Object} options (optional)\n */\n\nfunction GridWriteStream (grid, options) {\n\tif (!(this instanceof GridWriteStream))\n\t\treturn new GridWriteStream(grid, options);\n\n\tFlushWritable.call(this);\n\tthis._opened = false;\n\tthis._opening = false;\n\tthis._writable = true;\n\tthis._closing = false;\n\tthis._destroyed = false;\n\tthis._errorEmitted = false;\n\tthis._grid = grid;\n\n\t// a bit backwards compatible\n\tif (typeof options === 'string') {\n\t\toptions = { filename: options };\n\t}\n\tthis.options = options || {};\n\tif(this.options._id) {\n\t\tthis.id = grid.tryParseObjectId(this.options._id);\n\n\t\tif(!this.id) {\n\t\t\tthis.id = this.options._id;\n\t\t}\n\t}\n\n\tthis.name = this.options.filename;  // This may be undefined, that's okay\n\n\tif (!this.id) {\n\t\t//_id not passed or unparsable? This is a new file!\n\t\tthis.id = new grid.mongo.ObjectID();\n\t\tthis.name = this.name || '';  // A new file needs a name\n\t}\n\n\tthis.mode = 'w'; //Mongodb v2 driver have disabled w+ because of possible data corruption. So only allow `w` for now.\n\n\t// The value of this.name may be undefined. GridStore treats that as a missing param\n\t// in the call signature, which is what we want.\n\tthis._store = new grid.mongo.GridStore(grid.db, this.id, this.name, this.mode, this.options);\n\n\tthis._delayedWrite = null;\n\tthis._delayedFlush = null;\n\tthis._delayedClose = null;\n\n\tvar self = this;\n\n\tself._open();\n}\n\n/**\n * Inherit from stream.Writable (FlushWritable for workaround to defer finish until all data flushed)\n * @ignore\n */\n\nutil.inherits(GridWriteStream, FlushWritable);\n\n// private api\n\n/**\n * _open\n *\n * @api private\n */\n\nGridWriteStream.prototype._open = function () {\n\tif (this._opened) return;\n\tif (this._opening) return;\n\tthis._opening = true;\n\n\tvar self = this;\n\tthis._store.open(function (err, gs) {\n\t\tself._opening = false;\n\t\tif (err) return self._error(err);\n\t\tself._opened = true;\n\t\tself.emit('open');\n\n\t\t// If _close was called during _store opening, then it was delayed until now, so do the close now\n\t\tif (self._delayedClose) {\n\t\t\tvar closed = self._delayedClose.cb;\n\t\t\tself._delayedClose = null;\n\t\t\treturn self._closeInternal(closed);\n\t\t}\n\n\t\t// If _flush was called during _store opening, then it was delayed until now, so do the flush now (it's necessarily an empty GridFS file, no _write could have been called and have finished)\n\t\tif (self._delayedFlush) {\n\t\t\tvar flushed = self._delayedFlush;\n\t\t\tself._delayedFlush = null;\n\t\t\treturn self._flushInternal(flushed);\n\t\t}\n\n\t\t// If _write was called during _store opening, then it was delayed until now, so do the write now (_flush could not have been called yet as _write has not finished yet)\n\t\tif (self._delayedWrite) {\n\t\t\tvar delayedWrite = self._delayedWrite;\n\t\t\tself._delayedWrite = null;\n\t\t\treturn self._writeInternal(delayedWrite.chunk, delayedWrite.encoding, delayedWrite.done);\n\t\t}\n\t});\n}\n\n/**\n * _writeInternal\n *\n * @api private\n */\n\nGridWriteStream.prototype._writeInternal = function (chunk, encoding, done) {\n\t// If destroy or error no more data will be written.\n\tif (!this._writable) return;\n\n\tvar self = this;\n\t// Write the chunk to the GridStore. The write head automatically moves along with each write.\n\tthis._store.write(chunk, function (err, store) {\n\t\tif (err) return self._error(err);\n\n\t\t// Emit the write head position\n\t\tself.emit('progress', store.position);\n\n\t\t// We are ready to receive a new chunk from the writestream - call done().\n\t\tdone();\n\t});\n}\n\n/**\n * _write\n *\n * @api private\n */\n\nGridWriteStream.prototype._write = function (chunk, encoding, done) {\n\tif (this._opening) {\n\t\t// if we are still opening the store, then delay the write until it is open.\n\t\tthis._delayedWrite = {chunk: chunk, encoding: encoding, done: done};\n\t\treturn;\n\t}\n\n\t// otherwise, do the write now\n\tthis._writeInternal(chunk, encoding, done);\n}\n\n/**\n * _flushInternal\n *\n * @api private\n */\n\nGridWriteStream.prototype._flushInternal = function (flushed) {\n\tthis._close(flushed);\n}\n\n/**\n * _flush\n *\n * @api private\n */\n\nGridWriteStream.prototype._flush = function (flushed) {\n\t// _flush is called when all _write() have finished (even if no _write() was called (empty GridFS file))\n\n\tif (this._opening) {\n\t\t// if we are still opening the store, then delay the flush until it is open.\n\t\tthis._delayedFlush = flushed;\n\t\treturn;\n\t}\n\n\t// otherwise, do the flush now\n\tthis._flushInternal(flushed);\n}\n\n\n/**\n * _closeInternal\n *\n * @api private\n */\n\nGridWriteStream.prototype._closeInternal = function (cb) {\n\tif (!this._opened) return;\n\tif (this._closing) return;\n\tthis._closing = true;\n\n\tvar self = this;\n\tthis._store.close(function (err, file) {\n\t\tself._closing = false;\n\t\tself._opened = false;\n\t\tif (err) return self._error(err);\n\t\tself.emit('close', file);\n\n\t\tif (cb) cb();\n\t});\n}\n\n/**\n * _close\n *\n * @api private\n */\n\nGridWriteStream.prototype._close = function _close (cb) {\n\tif (this._opening) {\n\t\t// if we are still opening the store, then delay the close until it is open.\n\t\tthis._delayedClose = { cb: cb };\n\t\treturn;\n\t}\n\n\t// otherwise, do the close now\n\tthis._closeInternal(cb);\n}\n\n/**\n * _error\n *\n * @api private\n */\n\nGridWriteStream.prototype._error = function _error (err) {\n\t// Stop receiving more data to write, emit `error` and close the store\n\tif (this._errorEmitted) return;\n\tthis._errorEmitted = true;\n\n\tthis._writable = false;\n\tthis.emit('error', err);\n\tthis._close();\n}\n\n// public api\n\n/**\n * destroy\n *\n * @api public\n */\n\nGridWriteStream.prototype.destroy = function destroy (err) {\n\t// Abort the write stream, even if write not completed\n\tif (this._destroyed) return;\n\tthis._destroyed = true;\n\n\tvar self = this;\n\tprocess.nextTick(function() {\n\t\tself._error(err);\n\t});\n}\n\n\n/**\n * destroySoon\n *\n * @api public\n * @deprecated just use destroy()\n */\n\nGridWriteStream.prototype.destroySoon = function destroySoon () {\n\treturn this.destroy();\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}